// Generated by MODEX Version 2.11 - 3 November 2017
// Wed May 17 20:00:15 CST 2023 from ACCSimulator-C.c
#define accoff (1)
#define standby (2)
#define resume (3)
#define cruise (4)
#define follow (5)
#define stop (6)
#define accelerate (1)
#define decelerate (2)
#define fullystop (3)
#define keepspeed (4)
#define unknown (5)

int res_p_main;
bool lck_p_main_ret;
bool lck_p_main;
int res_p_GetSonarRawValue;
bool lck_p_GetSonarRawValue_ret;
bool lck_p_GetSonarRawValue;
bool lck_p_goMove_ret;
bool lck_p_goMove;
bool lck_p_DECelerate_ret;
bool lck_p_DECelerate;
bool lck_p_ACCelerate_ret;
bool lck_p_ACCelerate;
bool lck_p_calcTimeGap_ret;
bool lck_p_calcTimeGap;
c_state "double  par0_calPID" "Global"
c_state "double  res_p_calPID" "Global"
bool lck_p_calPID_ret;
bool lck_p_calPID;

int r;
 c_state "double  kd " "Global" "0.1"
 c_state "double  ki " "Global" "0.1"
 c_state "double  kp " "Global" "0.1"
 c_state "double  output" "Global"
 c_state "double  preverror " "Global" "0"
 c_state "double  error" "Global"
 c_state "double  minvalue " "Global" "0"
 c_state "double  maxvalue " "Global" "200"
 c_state "double  deltatime " "Global" "0.01"
 c_state "double  derivativegain" "Global"
 c_state "double  integralgain " "Global" "0"
 c_state "double  epsilon " "Global" "0.01"

int safetyTimeGap = 1;
int temp;
int timeGap = 0;
int minimumSpeed = 1;
int deltaX;
int desiredspeed = 20;
int initialspeed = 1;
int accelerationratio = 4;
int decelerationratio = 2;
int controlAction = 5;
int states = 1;
int frontdistance =(-1);
int safedistance = 20;
int currentspeed = 0;
int frontspeed = 15;

chan ret_p_main = [1] of { pid };
chan exc_cll_p_main = [0] of { pid };
chan req_cll_p_main = [1] of { pid };
chan ret_p_GetSonarRawValue = [1] of { pid };
chan exc_cll_p_GetSonarRawValue = [0] of { pid };
chan req_cll_p_GetSonarRawValue = [1] of { pid };
chan ret_p_goMove = [1] of { pid };
chan exc_cll_p_goMove = [0] of { pid };
chan req_cll_p_goMove = [1] of { pid };
chan ret_p_DECelerate = [1] of { pid };
chan exc_cll_p_DECelerate = [0] of { pid };
chan req_cll_p_DECelerate = [1] of { pid };
chan ret_p_ACCelerate = [1] of { pid };
chan exc_cll_p_ACCelerate = [0] of { pid };
chan req_cll_p_ACCelerate = [1] of { pid };
chan ret_p_calcTimeGap = [1] of { pid };
chan exc_cll_p_calcTimeGap = [0] of { pid };
chan req_cll_p_calcTimeGap = [1] of { pid };
chan ret_p_calPID = [1] of { pid };
chan exc_cll_p_calPID = [0] of { pid };
chan req_cll_p_calPID = [1] of { pid };
 c_state "double  diff" "Local p_calPID"
active proctype p_calPID( )
{
pid lck_id;
endRestart:
 atomic {
 nempty(req_cll_p_calPID) && !lck_p_calPID -> lck_p_calPID = 1;
 req_cll_p_calPID?lck_id; exc_cll_p_calPID?eval(lck_id);
 c_code { Pp_calPID->diff = now.par0_calPID; };
 lck_p_calPID = 0;
 };
    c_code { now.error=Pp_calPID->diff; };
    if
    :: c_expr { (now.error>now.epsilon) };
        c_code { now.integralgain+=(now.error*now.deltatime); };
    :: c_expr { !(now.error>now.epsilon) };
 fi;
    c_code { now.derivativegain+=((now.error-now.preverror)/now.deltatime); };
    c_code { now.output=(((now.kp*now.error)+(now.ki*now.integralgain))+(now.kd*now.derivativegain)); };
    if
    :: c_expr { (now.output>now.maxvalue) };
        c_code { now.output=now.maxvalue; };
    :: c_expr { !(now.output>now.maxvalue) };
      if
      :: c_expr { (now.output<now.minvalue) };
          c_code { now.output=now.minvalue; };
      :: c_expr { !(now.output<now.minvalue) };
 fi;
 fi;
    c_code { now.preverror=now.error; };
    c_code { now.temp=now.output; };
    atomic { !lck_p_calPID_ret -> lck_p_calPID_ret = 1 };
 c_code { now.res_p_calPID = (double ) now.output; }; goto Return;
Return: skip;
 ret_p_calPID!lck_id;
 goto endRestart
}
active proctype p_calcTimeGap()
{
pid lck_id;
endRestart:
 atomic {
 nempty(req_cll_p_calcTimeGap) && !lck_p_calcTimeGap -> lck_p_calcTimeGap = 1;
 req_cll_p_calcTimeGap?lck_id; exc_cll_p_calcTimeGap?eval(lck_id);
 lck_p_calcTimeGap = 0;
 };
    if
    :: c_expr { (now.currentspeed>0) };
        c_code { now.timeGap=(now.frontdistance / now.currentspeed); };
    :: c_expr { !(now.currentspeed>0) };
      c_code { now.timeGap=0; };
 fi;
Return: skip;
 ret_p_calcTimeGap!lck_id;
 goto endRestart
}
active proctype p_ACCelerate()
{
pid lck_id;
endRestart:
 atomic {
 nempty(req_cll_p_ACCelerate) && !lck_p_ACCelerate -> lck_p_ACCelerate = 1;
 req_cll_p_ACCelerate?lck_id; exc_cll_p_ACCelerate?eval(lck_id);
 lck_p_ACCelerate = 0;
 };
    if
    :: c_expr { ((now.states!=4)&&(now.states!=3)) };
 atomic {
  lck_p_calPID == 0 && empty(req_cll_p_calPID) -> req_cll_p_calPID!_pid;
  c_code { now.par0_calPID = (sqrt(fabs(((now.currentspeed*now.currentspeed)+(2*fabs(((now.deltaX+now.safetyTimeGap)-now.timeGap))))))-now.currentspeed); };
  exc_cll_p_calPID!_pid;
 }
 ret_p_calPID?eval(_pid);
 c_code { now.currentspeed+= now.res_p_calPID; now.lck_p_calPID_ret = 0; };
    :: c_expr { !((now.states!=4)&&(now.states!=3)) };
      c_code { now.currentspeed=now.currentspeed; };
 fi;
    if
    :: c_expr { (now.states==3) };
        c_code { now.currentspeed+=now.accelerationratio; };
    :: c_expr { !(now.states==3) };
 fi;
    if
    :: c_expr { (now.currentspeed>now.desiredspeed) };
        c_code { now.currentspeed=now.desiredspeed; };
    :: c_expr { !(now.currentspeed>now.desiredspeed) };
 fi;
Return: skip;
 ret_p_ACCelerate!lck_id;
 goto endRestart
}
active proctype p_DECelerate()
{
pid lck_id;
endRestart:
 atomic {
 nempty(req_cll_p_DECelerate) && !lck_p_DECelerate -> lck_p_DECelerate = 1;
 req_cll_p_DECelerate?lck_id; exc_cll_p_DECelerate?eval(lck_id);
 lck_p_DECelerate = 0;
 };
 atomic {
  lck_p_calPID == 0 && empty(req_cll_p_calPID) -> req_cll_p_calPID!_pid;
  c_code { now.par0_calPID = (sqrt(fabs(((now.currentspeed*now.currentspeed)+(2.7*fabs(((now.deltaX+now.safetyTimeGap)-now.timeGap))))))-now.currentspeed); };
  exc_cll_p_calPID!_pid;
 }
 ret_p_calPID?eval(_pid);
 c_code { now.currentspeed-= now.res_p_calPID; now.lck_p_calPID_ret = 0; };
    if
    :: c_expr { (now.currentspeed<=0) };
        c_code { now.currentspeed=0; };
    :: c_expr { !(now.currentspeed<=0) };
      if
      :: c_expr { (now.currentspeed>now.desiredspeed) };
          c_code { now.currentspeed=now.desiredspeed; };
      :: c_expr { !(now.currentspeed>now.desiredspeed) };
 fi;
 fi;
Return: skip;
 ret_p_DECelerate!lck_id;
 goto endRestart
}
active proctype p_goMove()
{
pid lck_id;
endRestart:
 atomic {
 nempty(req_cll_p_goMove) && !lck_p_goMove -> lck_p_goMove = 1;
 req_cll_p_goMove?lck_id; exc_cll_p_goMove?eval(lck_id);
 lck_p_goMove = 0;
 };
    if
    :: c_expr { (now.states!=5) };
 atomic {
  lck_p_ACCelerate == 0 && empty(req_cll_p_ACCelerate) -> req_cll_p_ACCelerate!_pid;
  exc_cll_p_ACCelerate!_pid;
 }
 ret_p_ACCelerate?eval(_pid);
 c_code { ; now.lck_p_ACCelerate_ret = 0; };
        if
        :: c_expr { (now.states==6) };
            c_code { now.currentspeed=0; };
        :: c_expr { !(now.states==6) };
 fi;
    :: c_expr { !(now.states!=5) };
      if
      :: c_expr { (now.states==5) };
 atomic {
  lck_p_DECelerate == 0 && empty(req_cll_p_DECelerate) -> req_cll_p_DECelerate!_pid;
  exc_cll_p_DECelerate!_pid;
 }
 ret_p_DECelerate?eval(_pid);
 c_code { ; now.lck_p_DECelerate_ret = 0; };
      :: c_expr { !(now.states==5) };
 fi;
 fi;
Return: skip;
 ret_p_goMove!lck_id;
 goto endRestart
}
active proctype p_GetSonarRawValue()
{
pid lck_id;
endRestart:
 atomic {
 nempty(req_cll_p_GetSonarRawValue) && !lck_p_GetSonarRawValue -> lck_p_GetSonarRawValue = 1;
 req_cll_p_GetSonarRawValue?lck_id; exc_cll_p_GetSonarRawValue?eval(lck_id);
 lck_p_GetSonarRawValue = 0;
 };
    c_code { now.r=(rand()%250); };
     atomic { !lck_p_GetSonarRawValue_ret -> lck_p_GetSonarRawValue_ret = 1 };
 c_code { now.res_p_GetSonarRawValue = (int ) now.r; }; goto Return;
Return: skip;
 ret_p_GetSonarRawValue!lck_id;
 goto endRestart
}
active proctype p_main()
{
int i = 1;
pid lck_id;
    c_code { now.states=2; };
    c_code { now.controlAction=5; };
    c_code { now.currentspeed=now.initialspeed; };
L_0:
    do
    :: c_expr { (Pp_main->i<300) };
 atomic {
  lck_p_GetSonarRawValue == 0 && empty(req_cll_p_GetSonarRawValue) -> req_cll_p_GetSonarRawValue!_pid;
  exc_cll_p_GetSonarRawValue!_pid;
 }
 ret_p_GetSonarRawValue?eval(_pid);
 c_code { now.frontdistance= now.res_p_GetSonarRawValue; now.lck_p_GetSonarRawValue_ret = 0; };
        if
        :: c_expr { (now.frontdistance<=(-1)) };
            c_code { now.frontdistance=250; };
        :: c_expr { !(now.frontdistance<=(-1)) };
 fi;
 atomic {
  lck_p_calcTimeGap == 0 && empty(req_cll_p_calcTimeGap) -> req_cll_p_calcTimeGap!_pid;
  exc_cll_p_calcTimeGap!_pid;
 }
 ret_p_calcTimeGap?eval(_pid);
 c_code { ; now.lck_p_calcTimeGap_ret = 0; };
        c_code { now.deltaX=(0.5+sqrt(now.timeGap)); };
        if
        :: c_expr { (now.deltaX<0) };
            c_code { now.deltaX=0; };
        :: c_expr { !(now.deltaX<0) };
          if
          :: c_expr { (now.deltaX>10) };
              c_code { now.deltaX=10; };
          :: c_expr { !(now.deltaX>10) };
 fi;
 fi;
        if
        :: c_expr { (now.states==2) };
            if
            :: c_expr { (now.currentspeed>now.minimumSpeed) };
                c_code { now.states=3; };
                c_code { now.controlAction=1; };
            :: c_expr { !(now.currentspeed>now.minimumSpeed) };
 fi;
        :: c_expr { !(now.states==2) };
          if
          :: c_expr { (now.states==3) };
              if
              :: c_expr { ((now.timeGap<(now.deltaX+now.safetyTimeGap))&&(now.timeGap!=0)) };
                  c_code { now.states=5; };
                  c_code { now.controlAction=2; };
              :: c_expr { !((now.timeGap<(now.deltaX+now.safetyTimeGap))&&(now.timeGap!=0)) };
                if
                :: c_expr { ((now.currentspeed==now.desiredspeed)&&(now.timeGap>now.safetyTimeGap)) };
                    c_code { now.states=4; };
                    c_code { now.controlAction=4; };
                :: c_expr { !((now.currentspeed==now.desiredspeed)&&(now.timeGap>now.safetyTimeGap)) };
                  if
                  :: c_expr { (now.timeGap==0) };
                      c_code { now.states=6; };
                      c_code { now.controlAction=3; };
                  :: c_expr { !(now.timeGap==0) };
                    if
                    :: c_expr { ((now.currentspeed<now.desiredspeed)&&(now.timeGap>now.safetyTimeGap)) };
                        c_code { now.states=3; };
                        c_code { now.controlAction=1; };
                    :: c_expr { !((now.currentspeed<now.desiredspeed)&&(now.timeGap>now.safetyTimeGap)) };
 fi;
 fi;
 fi;
 fi;
          :: c_expr { !(now.states==3) };
            if
            :: c_expr { (now.states==4) };
                if
                :: c_expr { ((now.timeGap>(now.deltaX+now.safetyTimeGap))&&(now.currentspeed==now.desiredspeed)) };
                    c_code { now.states=4; };
                    c_code { now.controlAction=4; };
                :: c_expr { !((now.timeGap>(now.deltaX+now.safetyTimeGap))&&(now.currentspeed==now.desiredspeed)) };
                  if
                  :: c_expr { (now.timeGap<(now.deltaX+now.safetyTimeGap)) };
                      c_code { now.states=5; };
                      c_code { now.controlAction=2; };
                  :: c_expr { !(now.timeGap<(now.deltaX+now.safetyTimeGap)) };
                    if
                    :: c_expr { ((now.currentspeed<now.desiredspeed)&&(now.timeGap>(now.deltaX+now.safetyTimeGap))) };
                        c_code { now.states=3; };
                        c_code { now.controlAction=1; };
                    :: c_expr { !((now.currentspeed<now.desiredspeed)&&(now.timeGap>(now.deltaX+now.safetyTimeGap))) };
 fi;
 fi;
 fi;
            :: c_expr { !(now.states==4) };
              if
              :: c_expr { (now.states==5) };
                  if
                  :: c_expr { ((now.timeGap>(now.deltaX+now.safetyTimeGap))&&(now.frontdistance>10)) };
                      c_code { now.states=3; };
                      c_code { now.controlAction=1; };
                  :: c_expr { !((now.timeGap>(now.deltaX+now.safetyTimeGap))&&(now.frontdistance>10)) };
                    if
                    :: c_expr { ((now.timeGap<=now.safetyTimeGap)&&(now.frontdistance<10)) };
                        c_code { now.states=6; };
                        c_code { now.controlAction=3; };
                    :: c_expr { !((now.timeGap<=now.safetyTimeGap)&&(now.frontdistance<10)) };
 fi;
 fi;
              :: c_expr { !(now.states==5) };
                if
                :: c_expr { (now.states==6) };
                    if
                    :: c_expr { ((now.timeGap>now.safetyTimeGap)||(now.frontdistance>10)) };
                        c_code { now.states=3; };
                        c_code { now.controlAction=1; };
                    :: c_expr { !((now.timeGap>now.safetyTimeGap)||(now.frontdistance>10)) };
 fi;
                :: c_expr { !(now.states==6) };
 fi;
 fi;
 fi;
 fi;
 fi;
 atomic {
  lck_p_goMove == 0 && empty(req_cll_p_goMove) -> req_cll_p_goMove!_pid;
  exc_cll_p_goMove!_pid;
 }
 ret_p_goMove?eval(_pid);
 c_code { ; now.lck_p_goMove_ret = 0; };
        c_code { Pp_main->i=(Pp_main->i+1); };
    goto L_0;
    :: c_expr { !(Pp_main->i<300) }; -> break
    od;
     atomic { !lck_p_main_ret -> lck_p_main_ret = 1 };
 c_code { now.res_p_main = (int ) 0; }; goto Return;
Return: skip;
}
